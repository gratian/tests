This is a test that uses an external measurement system to validate the
correctness of clock_gettime()/clock_nanosleep().

Build:
  * gcc -o clock-validation clock-validation.c -lpthread

Kernel version under test:
  * 3.14.25-rt22
  * 3.2.35-rt52

Measurement setup:
  * NI PXIe 8135 RT controller.
  * NI PXI 5124, 12 bit 200MS/s digitizer.

Test setup:
  * cRIO 9068 (ARM Cortex A9, Xilinx Zynq-7020) runs a C application, at RT
  priority, that for a number of iterations (10000) does the following loop:
    - set GPIO high;
    - start = clock_gettime();
    - clock_nanosleep() for a specified interval (513313ns);
    - set GPIO low;
    - stop = clock_gettime();
    - save stop - start;

  * The measurement system for the same number of iterations (10000):
    - configures the acquisition for 200 MSamples/second;
    - triggers the acquisition on  the GPIO low to high transition;
    - measures the interval the GPIO is high and stores it;

At the end of the run the "interval length" data obtained from the target is
plotted together with the data acquired by the external measurement system: top
graph in the screenshots available under the "results" folder.
The difference between the two sets of data is also plotted: bottom graph in
screenshots under "results". The mean, std. deviation and variance it is also
shown.

Observations:
  * The test runs in user space and can be preempted by interrupts and other
RT threads with priority > 98. This accounts for a couple spikes/big
differences between the data recorded by the external acquisition system versus
the real-time target.
  * The majority of the differences are less than 100ns and can be explained by
the lower resolution of the board used for acquisition (5ns step) and the fact
that changing the GPIO level and acquiring the current time are not coincident
or instantaneous operations.
  * The difference recorded with an average less than 100ns is a lot less than
the multi microsecond differences/slowdown observed in 3.14-rt vs. 3.2-rt.